<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>红黑树 | 远山淡影</title><meta name="author" content="远山淡影"><meta name="copyright" content="远山淡影"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ps：本文中结点和节点是同义词 红黑树的性质红黑树是一棵二叉搜索树，它在每一个结点上增加了一个存储位来表示结点的颜色 ，可以是RED或BLACK 。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树可以确保没有一条路径会比其它路径长出两倍，因而是近似于平衡的。 12345678struct node&#123;	char color;	int key;	*node left;	*n">
<meta property="og:type" content="article">
<meta property="og:title" content="红黑树">
<meta property="og:url" content="http://lebulang11.github.io/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/">
<meta property="og:site_name" content="远山淡影">
<meta property="og:description" content="ps：本文中结点和节点是同义词 红黑树的性质红黑树是一棵二叉搜索树，它在每一个结点上增加了一个存储位来表示结点的颜色 ，可以是RED或BLACK 。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树可以确保没有一条路径会比其它路径长出两倍，因而是近似于平衡的。 12345678struct node&#123;	char color;	int key;	*node left;	*n">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://lebulang11.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-08-04T04:37:44.000Z">
<meta property="article:modified_time" content="2025-08-04T05:19:33.453Z">
<meta property="article:author" content="远山淡影">
<meta property="article:tag" content="算法导论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://lebulang11.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "红黑树",
  "url": "http://lebulang11.github.io/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/",
  "image": "http://lebulang11.github.io/img/avatar.jpg",
  "datePublished": "2025-08-04T04:37:44.000Z",
  "dateModified": "2025-08-04T05:19:33.453Z",
  "author": [
    {
      "@type": "Person",
      "name": "远山淡影",
      "url": "http://lebulang11.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="http://lebulang11.github.io/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '红黑树',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/macos.jpg);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/goku.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">远山淡影</span></a><a class="nav-page-title" href="/"><span class="site-name">红黑树</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">红黑树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-08-04T04:37:44.000Z" title="发表于 2025-08-04 12:37:44">2025-08-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-08-04T05:19:33.453Z" title="更新于 2025-08-04 13:19:33">2025-08-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>ps：本文中结点和节点是同义词</p>
<h1 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h1><p>红黑树是一棵二叉搜索树，它在每一个结点上增加了一个存储位来表示结点的<strong>颜色</strong> ，可以是<strong>RED</strong>或<strong>BLACK</strong> 。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树可以确保没有一条路径会比其它路径长出两倍，因而是近似于平衡的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">char</span> color;</span><br><span class="line">	<span class="type">int</span> key;</span><br><span class="line">	*node left;</span><br><span class="line">	*node right;</span><br><span class="line">	*node p;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>如果一个结点没有子结点或父结点，则该结点相应指针属性的值为 NIL。我们将这些 NIL 视为二叉搜索树的叶结点（外部结点）的指针，而把带关键字的结点视为树的内部结点。</p>
<p>一棵红黑树是满足一下<strong>红黑性质</strong>的二叉搜索树：</p>
<ol>
<li>每个结点或是红色的，或是黑色的</li>
<li>根节点是黑色的</li>
<li>每个叶结点（NIL）是黑色的</li>
<li>如果一个结点是红色的，则它的两个子结点都是黑色的</li>
<li>对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点。 ^923721</li>
</ol>
<p><strong>黑高</strong>：从某个结点 x 出发（不含该结点）到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高，记为bh(x)。</p>
<blockquote>
<p>引理13.1 ：一棵有n个内部结点的红黑树的高度至多为 2lg(n+1)</p>
</blockquote>
<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>为了维护<strong>红黑性质</strong>，必须要修改树中某些结点的颜色以及指针结构。</p>
<p>指针结构的修改是通过旋转来完成的，旋转是一种能保持二叉搜索树性质的搜索树局部操作。</p>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p>当在某个结点 x 上做左旋时，假设它的右孩子为 y 而不是 T.nil（空结点）；x 可以为其右孩子不是T.nil 结点的树内任意结点。</p>
<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p>与左旋对称</p>
<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>将一个结点插入红黑树中，先将该结点设为红色，然后再对结点重新着色并旋转。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT(T,z) //z表示将要插入的结点，T表示红黑树</span><br><span class="line"> y = T.nil</span><br><span class="line"> x = T.root</span><br><span class="line"> while x != T.nil</span><br><span class="line">	 y = x</span><br><span class="line">	 if z.key &lt; x.key</span><br><span class="line">		 x = x.left</span><br><span class="line">	else</span><br><span class="line">		x = x.right</span><br><span class="line"> z.p = y</span><br><span class="line"> if y == T.nil  //空树</span><br><span class="line">	 T.root = z</span><br><span class="line"> elif z.key &lt; y.key</span><br><span class="line">	 y.left = z</span><br><span class="line"> else</span><br><span class="line">	 y.right = z</span><br><span class="line"> z.left = T.nil</span><br><span class="line"> z.right = T.nil</span><br><span class="line"> z.color = RED //新插入的结点默认为RED</span><br><span class="line"></span><br><span class="line"> RB-INSERT-FIXUP(T,z)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T,z)</span><br><span class="line"></span><br><span class="line">while z.p.color == RED</span><br><span class="line"> if z.p == z.p.p.left  // 如果当前插入结点的父结点是其父结点的左孩子结点</span><br><span class="line">	 y = z.p.p.right   // 令 y 等于其父结点的右孩子结点 AKA父结点的兄弟结点</span><br><span class="line">	 if y.color == RED  // 如果父结点的兄弟结点为 红色</span><br><span class="line">		 z.p.color = BLACK // 令父结点的颜色为黑色</span><br><span class="line">		 y.color = BLACK // 令兄弟结点的颜色为黑色</span><br><span class="line">		 z.p.p.color = RED // 令父结点的父结点的颜色为红色</span><br><span class="line">		 z = z.p.p  // 令 z 为父结点的父结点</span><br><span class="line">	elif z == z.p.right // 插入结点是右孩子</span><br><span class="line">		 z = z.p</span><br><span class="line">		 LEFT-ROTATE(T,z)</span><br><span class="line">	z.p.color = BLACK</span><br><span class="line">	z.p.p.color = RED</span><br><span class="line">	RIGHT-ROTATE(T,z.p.p)</span><br><span class="line"> else    //当前插入结点的父结点是其父结点的右孩子结点</span><br><span class="line">	 ...</span><br><span class="line">T.root.color = BLACK</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>为了理解 RB-INSERT-FIXUP 的工作过程，要将代码分成三个主要的步骤</p>
<ol>
<li>要确定当结点 z 被插入并着为红色后，红黑性质中有哪些不能继续保持（插入过程）</li>
<li>要分析 while 循环的总目标</li>
<li>要分析 while 循环中的三种情况，理解它们的功能</li>
</ol>
<p>插入一个新结点，那么这个树的结点仍然不是黑色就是红色，且所有NIL仍然是黑色的。因为插入的结点默认为红色（保持性质1），新插入的结点的左右孩子结点为 T.nil (保持性质2)。</p>
<p>对于性质5，即从一个指定结点开始的每条简单路径上的黑结点的个数都是相等的，也仍然成立，因为新插入的结点 z代替了一个 T.nil(黑色结点)，z为红色，而z的左右孩子仍然为黑色，因此性质5仍然保持。</p>
<h2 id="while循环的循环不变式"><a href="#while循环的循环不变式" class="headerlink" title="while循环的循环不变式"></a>while循环的循环不变式</h2><ol>
<li>结点z的颜色是RED</li>
<li>如果z.p是根节点，则z.p是黑结点</li>
<li>如果有任何红黑性质被破坏，则至多只有一条被破坏。如果性质2被破坏，则z为根节点且为红结点。如果性质4被破坏，则是因为z和z.p都是红结点</li>
</ol>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在循环的第一次迭代之前，从一棵正常的红黑树开始，并新增一个红结点z。</p>
<p>如果违反了性质2，则红色根节点一定是新增结点z，此时它是树中的唯一的内部结点。因为z的父结点以及左右孩子均为 T.nil，所以没有违反性质4.<br>如果违反了性质4，则由于 z 的子结点为黑色，且该树在新插入结点之前没有其他性质的违反，所以只是因为 z 和 z,p是黑色的。</p>
<h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>循环终止是因为 z.p是黑色的。如果 z 是根结点，则可能因为 z 是红色的违反性质 4，在RB-INSERT-FIXUP中的最后一行代码可恢复此性质。故此时所有红黑性质均成立。</p>
<h3 id="保持"><a href="#保持" class="headerlink" title="保持"></a>保持</h3><p>由于插入结点 z 的父结点是右孩子的情况和是左孩子的情况对称，故只用考虑是右孩子的情况即可。</p>
<h4 id="情况1：z的叔结点-y-是红色的"><a href="#情况1：z的叔结点-y-是红色的" class="headerlink" title="情况1：z的叔结点 y 是红色的"></a>情况1：z的叔结点 y 是红色的</h4><p>用z表示当前迭代中的结点 z ，z’ &#x3D; z.p.p表示在一次迭代第一行测试的结点 z</p>
<ol>
<li>因为这次迭代把 z.p.p着为红色，结点z’在下一次迭代的开始是红色</li>
<li>这次迭代中结点 z’.p 是 z.p.p.p，且这个结点的颜色不会改变。如果它是根节点，那么此次迭代之前它是黑色的，且它在下次迭代开始仍然是黑色的。</li>
<li>情况1保证性质1，性质3，性质5</li>
</ol>
<p>如果结点 z’ 在下一次迭代开始时是根节点，则情况1使其为黑色，使其新插入的结点 z 为红色。恢复了性质4。由于z’为红色，故做情况1违背了性质2，但最后一行默认设置根节点为黑色，故可恢复性质2。</p>
<p>如果结点 z’ 在下一次迭代开始时不是根节点，则情况1不会导致性质2被破坏，情况1可以修正z与z.p之间违背性质4。但使 z’ 为红色，若 z’.p是黑色，则 z’.p 和 z’之前没有违背情况，若z’.p是红色，则又违背了性质4。</p>
<h4 id="情况2：z的叔结点-y-是黑色的且-z-是一个右孩子"><a href="#情况2：z的叔结点-y-是黑色的且-z-是一个右孩子" class="headerlink" title="情况2：z的叔结点 y 是黑色的且 z 是一个右孩子"></a>情况2：z的叔结点 y 是黑色的且 z 是一个右孩子</h4><h4 id="情况3：-z的叔节点-y-是黑色的且-z-是一个左孩子"><a href="#情况3：-z的叔节点-y-是黑色的且-z-是一个左孩子" class="headerlink" title="情况3： z的叔节点 y 是黑色的且 z 是一个左孩子"></a>情况3： z的叔节点 y 是黑色的且 z 是一个左孩子</h4><p>在情况2和情况3 中，z的叔结点 y 是黑色的。通过 z 是 z.p 的右孩子还是左孩子来区别这两种情况。<br>在情况2中，结点 z 是它的父结点的右孩子，可以使用一个左旋来将此情况转变此情况为性质3，此时结点z为左孩子。</p>
<p>因为z 和 z.p 都是红色的，所以该旋转对于结点的黑高和性质5都无影响。</p>
<p>无论是直接进入情况3，还是通过情况2进入情况3，z 的叔结点 y 总是黑色的，否则就是情况 1.</p>
<p>此外 z.p.p存在，因为要进入循环，则 z.p 为 RED， 又由循环不变式可知，红黑树的根节点必为黑色，故 z.p 必不是根节点， z.p有父结点。</p>
<p>![[红黑树图13-6.png]]</p>
<p>令 z &#x3D; z.p ，即将 z 上移一层，然后执行 LEFT-ROTATE ，又将 z 下移了一层，z.p.p的身份保持不变。在情况3中，改变某些结点的颜色并做一次右旋，保持性质5。自此，所有性质得到保证，循环终止。</p>
<p>下面证明情况2和情况3保持了循环不变式。</p>
<ol>
<li>情况2 让 z 指向红色的 z.p。在情况 2 和 情况 3 中 z 及 z 的颜色都不再改变</li>
<li>情况 3 将 z.p 着成黑色，使得如果 z.p 在下一次迭代开始时是根节点，则它是黑色的。</li>
<li>性质1，3，5仍然得到保持。</li>
</ol>
<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>从一棵红黑树中删除结点的过程是基于TREE-DELETE过程而来的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RB-TRANSPLANT(T,u,v)</span><br><span class="line"></span><br><span class="line">if u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line">elif u = u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line">else</span><br><span class="line">	u.p.right = v</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE(T,z)</span><br><span class="line"></span><br><span class="line">y = z</span><br><span class="line">y-original-color = y.color</span><br><span class="line">if z.left = T.nil</span><br><span class="line">	x = z.right</span><br><span class="line">	RB-TRANSPLANT(T,z,z.right)</span><br><span class="line">elif z.right = T.nil</span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T,z,z.left)</span><br><span class="line">else                    // z有两个孩子结点</span><br><span class="line">	y = TREE-MINIMUM(z.right)  // 找到z的右子树中的最小值</span><br><span class="line">	y-original-color = y.color  </span><br><span class="line">	x = y.right  // 设 x 等于 y的右子树</span><br><span class="line">	if y.p == z  // 如果y的父结点就是 z ，那么以y为结点的二叉搜索树必然只有右孩子结点</span><br><span class="line">		x.p =y  // 设x的父结点为 y</span><br><span class="line">	else          // y的父结点不是z</span><br><span class="line">		RB-TRANSPLANT(T,y,y.right) 用 y 的右子树代替y的位置</span><br><span class="line">		y.right = z.right   // 用z的右子树代替 y的右子树</span><br><span class="line">		y.right.p = y   // 将y的右子树（原先z的右子树）的父结点设为 y</span><br><span class="line">	RB-TRANSPLANT(T,z,y)  </span><br><span class="line">	y.left = z.left</span><br><span class="line">	y.left.p = y</span><br><span class="line">	y.color = z.color</span><br><span class="line"></span><br><span class="line">if y-original-color == BLACK</span><br><span class="line">	RB-DELETE-FIXUP(T,x)</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>对于将要删除的只有左孩子&#x2F;右孩子的结点，这样的结点必然是黑结点，孩子结点为红色，因为如果这个结点是红色，那么它一个子树的黑高为 0 ，而另一个不为 0。对于这样的直接用孩子代替结点 z ，再将其变为黑色。</p>
<p><strong>y的性质</strong></p>
<ol>
<li>始终维持结点 y 为从树中删除的结点或者移至树内的结点。</li>
<li>由于结点y的颜色可能改变，变量 y-original-color 存储了发生改变前y的颜色。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">RB-DELETE-FIXUP(T,x)</span><br><span class="line"></span><br><span class="line">while x != T.root and x.color == BLACK</span><br><span class="line">	if x == x.p.left</span><br><span class="line">		w = x.p.right</span><br><span class="line">		if w.color == RED</span><br><span class="line">			w.color = BLACK</span><br><span class="line">			x.p.color = RED</span><br><span class="line">			LEFT-ROTATE(T,x.p)</span><br><span class="line">			w = x.p.right</span><br><span class="line">		if w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">			w.color = RED</span><br><span class="line">			x = x.p</span><br><span class="line">		else if</span><br><span class="line">			  w.right.color == BLACK</span><br><span class="line">			  w.color = RED</span><br><span class="line">			  RIGHT-ROTATE(T,w)</span><br><span class="line">			  w = x.p.right</span><br><span class="line">		w.color = x.p.color</span><br><span class="line">		x.p.color = BLACK</span><br><span class="line">		w.right.color = BLACK</span><br><span class="line">		LEFT-ROTATE(T,x.p)</span><br><span class="line">		x = T.root</span><br><span class="line">	</span><br><span class="line">	else (same as then clause with &quot;right&quot; and &quot;left&quot; exchanged)</span><br><span class="line"></span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure>

<hr>
<p>删除的是<em>只有左孩子&#x2F;只有右孩子</em>：代替后变黑</p>
<ol>
<li>红色结点：首先，它肯定只有右孩子结点，删除后，第一，它不会影响它在的路径的黑高；第二它不会使两个红色结点相邻，因为它的右孩子结点颜色为黑色。</li>
<li>黑色结点：它也只有右孩子，删除后，它会使它在的路径的黑高减去1，根据二叉搜索树的删除，只有右孩子可以直接替代，因此用右孩子（<em>红色</em>）替代，然后把这个红色结点变成红色，这样这个路径上的黑高就不会变化。</li>
</ol>
<hr>
<p>如果（实际）删除的是没有孩子的结点（设r为兄弟的右孩子，s为要删除的结点的兄弟结点，p为删除结点的父结点）</p>
<blockquote>
<p>因为删除后的替代结点要么是一个左孩子（右子树中的最小结点），或者是待删除的右孩子结点。<br>如果是左孩子，那么它最多就一个右孩子了，不可能有左孩子（不然就不是待删除结点的右子树中的最小结点了）。如果它是右孩子结点，那么它最多只有右孩子结点（如果有左孩子结点，那么它也不是右子树中最小的）。</p>
</blockquote>
<p><strong>双黑节点</strong><br>删除（移动）黑色结点（设为y）会导致包含该节点的任意简单路径上黑色节点个数减少一。因此 y 的任何祖先都不满足<a href="%E7%BA%A2%E9%BB%91%E6%A0%91#%5E923721">性质5</a>。改正这一问题的方法是将现在占有 y 原来位置的节点 x 视为还有一重额外的黑色。</p>
<ol>
<li>红节点：删除后无需任何调整</li>
<li>黑结点<ol>
<li>兄弟是黑色<ol>
<li>兄弟至少有一个红孩子：（LL，RR，LR，RL）变色+旋转<ol>
<li>LL型：变色（r变s，s变p，p变黑）右旋，双黑变单黑</li>
<li>RR型：变色（r变s，s变p，p变黑）左旋，双黑变单黑</li>
<li>LR型：变色（r变p，p变黑）左旋p的左孩子，然后右旋p，双黑变单黑</li>
<li>RL型：变色（r变p，p变黑）右旋p的右孩子，然后左旋p，双黑变单黑</li>
</ol>
</li>
<li>兄弟的孩子全是黑色<ol>
<li>兄弟变红，双黑上移，遇到红色结点或根结点直接变成黑色</li>
</ol>
</li>
</ol>
</li>
<li>兄弟是红色<ol>
<li>兄父变色，朝双黑旋转（保持双黑继续调整）</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>没有孩子的红色结点删除后，显然不破坏任何在删除中可能被破坏的性质</p>
<ol>
<li>根节点为黑色：删除的是红色结点，根节点不是红色，对根节点没有影响</li>
<li>黑高没有变化：删除的是红色结点，黑高指的是其到叶结点经过的黑色结点数。</li>
<li>不存在相邻的红色结点：显然的，因为它没有孩子，同时父结点为黑色。</li>
</ol>
<p>没有孩子的其实对应算法导论里 x（替换被删除的结点 y）就是T.nil。所以x是双黑结点。</p>
<p><strong>待删除结点（为黑色，且兄弟是红色）</strong><br>这一步是为了转换成<em>兄弟为黑色且兄弟至少有一个红孩子或兄弟为黑色且全是黑色孩子的情况）</em>。<br>兄父变色，那么s为黑色，p为红色。朝双黑旋转，如果双黑是p的左孩子，那么就是左旋，p变成了 s 的左孩子。s的左孩子（黑色）变成了p的右孩子。此时为兄弟为黑色且兄弟的孩子…。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://lebulang11.github.io">远山淡影</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://lebulang11.github.io/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/">http://lebulang11.github.io/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://lebulang11.github.io" target="_blank">远山淡影</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/">算法导论</a></div><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/08/13/%E5%85%AB%E6%9C%88ac/" title="八月ac"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">八月ac</div></div><div class="info-2"><div class="info-item-1">113.路径总和 II给你二叉树的根节点root 和一个整数目标和targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径 回溯-添加的角度当前操作：维护一个sum，用目标值减去当前节点的值 子问题：进入左孩子或右孩子，用目标值减去其值 下一个子问题：same 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * public class TreeNode &#123; *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode() &#123;&#125; *     TreeNode(int val) &#123; this.val = val; &#125; *     TreeNode(int val, TreeNode left, TreeNode right) &#123; *         thi...</div></div></div></a><a class="pagination-related" href="/2025/08/04/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot;  More info: Writing Run server1$ hexo server  More info: Server Generate static files1$ hexo generate  More info: Generating Deploy to remote sites1$ hexo deploy  More info: Deployment </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/06/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-14</div><div class="info-item-2">动态规划</div></div><div class="info-2"><div class="info-item-1">引言 动态规划与分治方法相似，都是通过组合子问题的解来求解原问题。 分治方法将问题划分为互不相交的子问题，递归地求解子问题，再将它们的解组合起来，求出原问题的解。 动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题（子问题的求解是递归进行的，将其划分为更小的子问题）。 在这种情况下，分治算法会重复计算很多子问题，而动态规划会将子问题的解存储起来（如用数组），从而避免每次求解一个子问题都需要重新计算。  动态规划方法通常用来求解最优化问题，这类问题可以有很多可行解，每个解都有一个值，我们希望寻找具有最优值的解。 我们称这样的解为问题的一个最优解（一个问题可能有很多最优解）。 动态规划的四个步骤  求出一个最优子结构 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造一个最优解  DP萌新三步  思考回溯应该怎么写 入参和返回值 递归到哪里 递归边界和入口   改成记忆化搜索 1比1翻译成递推  钢条切割问题描述给定一段长度为 n 英寸的钢条和一个价格表 $p_i(i&#x3D;1,2,\dots,n)$ ,求切割钢条方案，使得销售收益$...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">远山淡影</div><div class="author-info-description">code my life</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lebulang11"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/lebulang11" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:2937941726@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.</span> <span class="toc-text">红黑树的性质</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC"><span class="toc-number">2.</span> <span class="toc-text">旋转</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E6%97%8B"><span class="toc-number">2.1.</span> <span class="toc-text">左旋</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E6%97%8B"><span class="toc-number">2.2.</span> <span class="toc-text">右旋</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8F%92%E5%85%A5"><span class="toc-number">3.</span> <span class="toc-text">插入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">while循环的循环不变式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">3.1.2.</span> <span class="toc-text">终止</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81"><span class="toc-number">3.1.3.</span> <span class="toc-text">保持</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B51%EF%BC%9Az%E7%9A%84%E5%8F%94%E7%BB%93%E7%82%B9-y-%E6%98%AF%E7%BA%A2%E8%89%B2%E7%9A%84"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">情况1：z的叔结点 y 是红色的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B52%EF%BC%9Az%E7%9A%84%E5%8F%94%E7%BB%93%E7%82%B9-y-%E6%98%AF%E9%BB%91%E8%89%B2%E7%9A%84%E4%B8%94-z-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%B3%E5%AD%A9%E5%AD%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">情况2：z的叔结点 y 是黑色的且 z 是一个右孩子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%83%85%E5%86%B53%EF%BC%9A-z%E7%9A%84%E5%8F%94%E8%8A%82%E7%82%B9-y-%E6%98%AF%E9%BB%91%E8%89%B2%E7%9A%84%E4%B8%94-z-%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B7%A6%E5%AD%A9%E5%AD%90"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">情况3： z的叔节点 y 是黑色的且 z 是一个左孩子</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">4.</span> <span class="toc-text">删除</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/22/Computer%20Network/" title="计算机网络复习笔记">计算机网络复习笔记</a><time datetime="2025-08-22T13:10:39.319Z" title="发表于 2025-08-22 21:10:39">2025-08-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/13/%E5%85%AB%E6%9C%88ac/" title="八月ac">八月ac</a><time datetime="2025-08-13T01:36:00.000Z" title="发表于 2025-08-13 09:36:00">2025-08-13</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/%E7%BA%A2%E9%BB%91%E6%A0%91/" title="红黑树">红黑树</a><time datetime="2025-08-04T04:37:44.000Z" title="发表于 2025-08-04 12:37:44">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/04/hello-world/" title="Hello World">Hello World</a><time datetime="2025-08-04T03:34:41.081Z" title="发表于 2025-08-04 11:34:41">2025-08-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/06/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划">动态规划</a><time datetime="2024-06-14T06:32:00.000Z" title="发表于 2024-06-14 14:32:00">2024-06-14</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/pink.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By 远山淡影</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.3</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>